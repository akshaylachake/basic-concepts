<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JS QnA</title>
    <link rel="stylesheet" href="../styles/style.css" />
  </head>
  <body>
    <a href="/"><< Back</a>
    <h2>
      <i
        >Explain the purpose of the querySelector method in JavaScript, and
        provide an example of how to use it.</i
      >
    </h2>
    <p>
      <b>Answer:</b><br />
      The querySelector method in JavaScript allows you to select elements from
      the DOM using CSS-style selectors. It returns the first element that
      matches the selector. Here’s an example:
    </p>

    <pre><code>
      const element = document.querySelector(".my-class");
    </code></pre>
    <p>
      This example selects the first element with the class “my-class” and
      assigns it to the element variable.
    </p>
    <hr />
    <h2>
      <i
        >Explain the concept of event handling in JavaScript and provide an
        example of attaching an event listener to a button.</i
      >
    </h2>
    <p>
      <b>Answer:</b><br />
      In JavaScript, event handling involves responding to user actions or
      events triggered by the browser. Event listeners are functions that listen
      for specific events and execute code in response. Here’s an example of
      attaching an event listener to a button:
    </p>

    <pre>
      <code> 
        &lt;button id="myButton"&gt;Click me&lt;/button&gt;
        
        const button = document.getElementById("myButton");

        button.addEventListener("click", () => {
          console.log("Button clicked!");
        });
      </code>
    </pre>
    <p>
      In this example, the event listener is attached to the button element with
      the id “myButton.” When the button is clicked, the anonymous arrow
      function is executed, and it logs “Button clicked!” to the console.
    </p>
    <hr />
    <h2>Find the output</h2>
    <pre>
    <code>
    console.log("start");
    setTimeout(()=>console.log('1'),0);
    Promise.resolve().then(()=>console.log('2'));
    setTimeout(()=>console.log('3'),0);
    console.log("end");

    // output
    start
    end
    2
    1
    3
    </code>
    </pre>
    <ul>
      <li>
        Execution Breakdown
        <ul>
          <li>
            Components:
            <ol>
              <li>Call Stack: Tracks function calls in a LIFO order.</li>
              <li>
                Web APIs: Handle asynchronous tasks like timers and
                HTTPrequests.
              </li>
              <li>Task Queue: Stores tasks like setTimeout and UI events.</li>
              <li>
                Microtask Queue: Handles high-priority tasks like Promise
                callbacks.
              </li>
            </ol>
          </li>
          <li>
            Execution Order:
            <ol>
              <li>Synchronous code executes first (call stack).</li>
              <li>Microtasks are processed next.</li>
              <li>Macrotasks are executed afterward.</li>
            </ol>
          </li>
          <li>
            Synchronous Code: All synchronous code runs first. There is no
            synchronous code before the setTimeout and Promise in this example,
            so we move directly to the asynchronous operations.
          </li>
          <li>
            Microtasks: Promises are considered microtasks and have a higher
            priority than macrotasks. They will be executed as soon as the
            current synchronous code is done and before any macrotasks.
          </li>
          <li>
            Macrotasks: setTimeout is a macrotask and will be executed after all
            microtasks in the current tick of the event loop are completed.
          </li>
        </ul>
      </li>

      <li>
        Step-by-Step Execution
        <ul>
          <li>
            First setTimeout: A setTimeout with 0 delay is added to the
            macrotask queue.
          </li>
          <li>
            Promise: The promise is resolved immediately and its .then()
            callback is added to the microtask queue.
          </li>
          <li>
            Second setTimeout: Another setTimeout with 0 delay is added to the
            macrotask queue.
          </li>
        </ul>
      </li>
    </ul>
    <hr />
    <pre>
    <code>
    const obj = { a: 1, b: 2 };
    const key = 'c';
    const obj1 = obj;
    obj1.d = 'hello';
 
    console.log(obj);
    console.log(obj[key]);

    // output
    {a:1,b:2,d:'hello'}
    undefined
    </code>
    </pre>
    <ul>
      <li>
        Execution Breakdown
        <ul>
          <li>
            <pre><code>
              const obj = { a: 1, b: 2 };
            </code></pre>
            'obj' is declared as a constant. This means 'obj' will always
            reference the same object, but the contents of the object can be
            modified.
          </li>
          <li>
            <pre><code>
              const obj1 = obj;
            </code></pre>
            'obj1' is another reference to the same object that 'obj'
            references. Both 'obj' and 'obj1' now point to the same object in
            memory.
          </li>
          <li>
            <pre><code>
              obj1.d = 'hello';
            </code></pre>
            This line adds a new property 'd' to the object. Since 'obj1' and
            'obj' reference the same object, the modification is reflected in
            both.
          </li>
          <li>
            <pre><code>
            console.log(obj);  // { a: 1, b: 2, d: 'hello' }
            console.log(obj[key]);  // undefined
            </code></pre>
            The console.log(obj); statement outputs the updated object: { a: 1,
            b: 2, d: 'hello' }. The console.log(obj[key]); statement outputs
            undefined because key is 'c', and there is no property c in the
            object.
          </li>
        </ul>
      </li>
    </ul>
    <hr />
    <pre>
    <code> x = 7 + "8"; console.log(x); // output 78 </code>
    </pre>
    <ul>
      <li>
        In non-strict mode:<br />
        If you don’t declare a variable and just assign it, JavaScript
        implicitly creates a global variable named x. This is generally
        considered bad practice, because it pollutes the global scope and can
        lead to bugs.
      </li>
      <li>
        In strict mode ("use strict"): <br />
        You would get a ReferenceError:
      </li>
    </ul>
    <hr />
    <pre>
    <code> 
      var arr = [];
      arr[0] = 1;
      arr[1] = 2;
      arr.foo = 3
      console.log(arr.length); 
      
      // output 
      2 
    </code>
    </pre>
    <ul>
      <li>
        The code creates an array named arr and assigns the values 'a' and 'b'
        to its first two elements. The line arr.foo = 'c' adds a property named
        'foo' to the array object and assigns it the value 'c'. However, this
        does not affect the length of the array, which remains 2. Therefore, the
        alert(arr.length) statement will display the value 2.
      </li>
    </ul>
    <hr />
    <pre>
    <code> 
      4+2+3+"1"
      
      // output 
      91
    </code>
    </pre>
    <ul>
      <li>
        The statement "10 4321 91" is not a valid mathematical expression. It
        appears to be a list of numbers separated by spaces. Therefore, it does
        not evaluate to a specific value. The answer "91" is likely just the
        last number in the list, but it does not represent the evaluation of the
        statement.
      </li>
    </ul>
    <hr />
    <pre>
    <code> 
      function foo(){}
      delete foo.length;
      console.log(typeOf foo.length);

      // output 
      Number
    </code>
    </pre>
    <ul>
      <li>
        Step-by-step:
        <br />
        1. function foo(){} You define a function named foo.
        <br />
        2. foo.length This is a built-in property of functions. It returns the
        number of expected arguments (parameters) of the function. Since foo has
        no parameters, foo.length === 0.
        <br />
        3. delete foo.length You're trying to delete a built-in property. But...
        length is non-configurable, so: The delete fails silently in non-strict
        mode. It throws an error in strict mode.
        <br />
        4. console.log(typeof foo.length) The delete didn't work, so foo.length
        is still there. So you're logging: typeOf 0 i.e Number
      </li>
    </ul>
    <hr />
    <pre>
    <code>
      <img src="../assets/q3.jpg" /><br />

      //output
      3, 1
    </code>
    </pre>
    <hr />
    <pre>
    <code>
      <img src="../assets/q4.jpg" /><br />

      //output
      3
    </code>
    </pre>
    <hr />
    <pre>
    <code>
      What value is alerted?  
      <img src="../assets/q10.jpg" /><br />

      // 4
    </code>
    </pre>
    <ul>
      <li>
        The code defines a global variable x with a value of 4 and an object obj
        with a property x set to 3 and a method bar(). Inside bar(), a local
        variable x is declared with a value of 2, and a setTimeout() function is
        called. The setTimeout() function defines another nested function that
        declares a local variable x with a value of 1 and then alerts the value
        of this.x. When obj.bar() is called, the setTimeout() function schedules
        the nested function to be executed after 1000 milliseconds (1 second).
        When the nested function is executed, the value of this refers to the
        global window object, not the obj object. Therefore, this.x refers to
        the global variable x, which has a value of 4. Hence, the value alerted
        is 4.
      </li>
    </ul>
    <script></script>
  </body>
</html>
