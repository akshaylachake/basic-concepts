<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JS QnA</title>
    <link rel="stylesheet" href="../styles/style.css" />
  </head>
  <body>
    <a href="/"><< Back</a>
    <h2>
      <i
        >Explain the purpose of the querySelector method in JavaScript, and
        provide an example of how to use it.</i
      >
    </h2>
    <p>
      <b>Answer:</b><br />
      The querySelector method in JavaScript allows you to select elements from
      the DOM using CSS-style selectors. It returns the first element that
      matches the selector. Here’s an example:
    </p>

    <pre><code>
      const element = document.querySelector(".my-class");
    </code></pre>
    <p>
      This example selects the first element with the class “my-class” and
      assigns it to the element variable.
    </p>
    <hr />
    <h2>
      <i
        >Explain the concept of event handling in JavaScript and provide an
        example of attaching an event listener to a button.</i
      >
    </h2>
    <p>
      <b>Answer:</b><br />
      In JavaScript, event handling involves responding to user actions or
      events triggered by the browser. Event listeners are functions that listen
      for specific events and execute code in response. Here’s an example of
      attaching an event listener to a button:
    </p>

    <pre>
      <code> 
        &lt;button id="myButton"&gt;Click me&lt;/button&gt;
        
        const button = document.getElementById("myButton");

        button.addEventListener("click", () => {
          console.log("Button clicked!");
        });
      </code>
    </pre>
    <p>
      In this example, the event listener is attached to the button element with
      the id “myButton.” When the button is clicked, the anonymous arrow
      function is executed, and it logs “Button clicked!” to the console.
    </p>
    <hr />
    <h2>Find the output</h2>
    <pre>
    <code>
    console.log("start");
    setTimeout(()=>console.log('1'),0);
    Promise.resolve().then(()=>console.log('2'));
    setTimeout(()=>console.log('3'),0);
    console.log("end");

    // output
    start
    end
    2
    1
    3
    </code>
    </pre>
    <ul>
      <li>
        Execution Breakdown
        <ul>
          <li>
            Components:
            <ol>
              <li>Call Stack: Tracks function calls in a LIFO order.</li>
              <li>
                Web APIs: Handle asynchronous tasks like timers and
                HTTPrequests.
              </li>
              <li>Task Queue: Stores tasks like setTimeout and UI events.</li>
              <li>
                Microtask Queue: Handles high-priority tasks like Promise
                callbacks.
              </li>
            </ol>
          </li>
          <li>
            Execution Order:
            <ol>
              <li>Synchronous code executes first (call stack).</li>
              <li>Microtasks are processed next.</li>
              <li>Macrotasks are executed afterward.</li>
            </ol>
          </li>
          <li>
            Synchronous Code: All synchronous code runs first. There is no
            synchronous code before the setTimeout and Promise in this example,
            so we move directly to the asynchronous operations.
          </li>
          <li>
            Microtasks: Promises are considered microtasks and have a higher
            priority than macrotasks. They will be executed as soon as the
            current synchronous code is done and before any macrotasks.
          </li>
          <li>
            Macrotasks: setTimeout is a macrotask and will be executed after all
            microtasks in the current tick of the event loop are completed.
          </li>
        </ul>
      </li>

      <li>
        Step-by-Step Execution
        <ul>
          <li>
            First setTimeout: A setTimeout with 0 delay is added to the
            macrotask queue.
          </li>
          <li>
            Promise: The promise is resolved immediately and its .then()
            callback is added to the microtask queue.
          </li>
          <li>
            Second setTimeout: Another setTimeout with 0 delay is added to the
            macrotask queue.
          </li>
        </ul>
      </li>
    </ul>
    <hr />
    <pre>
    <code>
    const obj = { a: 1, b: 2 };
    const key = 'c';
    const obj1 = obj;
    obj1.d = 'hello';
 
    console.log(obj);
    console.log(obj[key]);

    // output
    {a:1,b:2,d:'hello'}
    undefined
    </code>
    </pre>
    <ul>
      <li>
        Execution Breakdown
        <ul>
          <li>
            <pre><code>
              const obj = { a: 1, b: 2 };
            </code></pre>
            'obj' is declared as a constant. This means 'obj' will always
            reference the same object, but the contents of the object can be
            modified.
          </li>
          <li>
            <pre><code>
              const obj1 = obj;
            </code></pre>
            'obj1' is another reference to the same object that 'obj'
            references. Both 'obj' and 'obj1' now point to the same object in
            memory.
          </li>
          <li>
            <pre><code>
              obj1.d = 'hello';
            </code></pre>
            This line adds a new property 'd' to the object. Since 'obj1' and
            'obj' reference the same object, the modification is reflected in
            both.
          </li>
          <li>
            <pre><code>
            console.log(obj);  // { a: 1, b: 2, d: 'hello' }
            console.log(obj[key]);  // undefined
            </code></pre>
            The console.log(obj); statement outputs the updated object: { a: 1,
            b: 2, d: 'hello' }. The console.log(obj[key]); statement outputs
            undefined because key is 'c', and there is no property c in the
            object.
          </li>
        </ul>
      </li>
    </ul>
    <hr />
    <pre>
    <code> x = 7 + "8"; console.log(x); // output 78 </code>
    </pre>
    <ul>
      <li>
        In non-strict mode:<br />
        If you don’t declare a variable and just assign it, JavaScript
        implicitly creates a global variable named x. This is generally
        considered bad practice, because it pollutes the global scope and can
        lead to bugs.
      </li>
      <li>
        In strict mode ("use strict"): <br />
        You would get a ReferenceError:
      </li>
    </ul>
    <script></script>
  </body>
</html>
